meta {
  name: Load Test
  type: http
  seq: 4
}

get {
  url: {{baseUrl}}/zbrodniarze
  body: none
  auth: none
}

assert {
  res.status: eq 200
  res.body: isJson
}

tests {
  test("Load test - Single request performance", function() {
    expect(res.getStatus()).to.equal(200);
    expect(res.getResponseTime()).to.be.below(500);
  });

  test("Response structure is valid under load", function() {
    const data = res.getBody();
    expect(data).to.be.an('array');

    if (data.length > 0) {
      data.forEach(function(item) {
        expect(item).to.have.property('id');
        expect(item).to.have.property('username');
        expect(item).to.have.property('type');
        expect(item).to.have.property('timestamp');
      });
    }
  });

  test("Cache headers present during load", function() {
    expect(res.getHeader('cache-control')).to.equal('public, max-age=300');
    expect(res.getHeader('vary')).to.equal('Accept-Encoding');
  });

  test("Server handles concurrent requests", function() {
    // This test simulates load by checking response consistency
    expect(res.getBody()).to.be.an('array');
    expect(res.getStatus()).to.equal(200);
  });

  test("Performance remains consistent", function() {
    const responseTime = res.getResponseTime();

    // Under load with cache, responses should still be fast
    expect(responseTime).to.be.below(200);

    console.log(`Load test response time: ${responseTime}ms`);
  });

  test("Data integrity maintained under load", function() {
    const data = res.getBody();

    // Check data ordering is maintained
    if (data.length > 1) {
      for (let i = 0; i < data.length - 1; i++) {
        const current = new Date(data[i].timestamp);
        const next = new Date(data[i + 1].timestamp);
        expect(current.getTime()).to.be.at.least(next.getTime());
      }
    }
  });

  test("Cache effectiveness under load", function() {
    const responseTime = res.getResponseTime();
    const firstRequestTime = bru.getVar('firstRequestTime');

    if (firstRequestTime) {
      // Even under load, cached responses should be faster than initial DB query
      expect(responseTime).to.be.below(parseFloat(firstRequestTime));
    }
  });

  test("No cache corruption under load", function() {
    const data = res.getBody();

    // Verify all required fields are present and valid
    data.forEach(function(item) {
      expect(item.id).to.be.a('number').and.above(0);
      expect(item.username).to.be.a('string').and.not.empty;
      expect(item.type).to.be.oneOf(['ban', 'timeout']);
      expect(new Date(item.timestamp).getTime()).to.not.be.NaN;
    });
  });

  test("Memory leak indicators", function() {
    // Check for reasonable response times indicating no memory issues
    expect(res.getResponseTime()).to.be.below(1000);

    // Large response sizes could indicate memory leaks
    const responseSize = JSON.stringify(res.getBody()).length;
    expect(responseSize).to.be.below(1000000); // 1MB limit
  });

  test("Content-Type consistency under load", function() {
    expect(res.getHeader('content-type')).to.equal('application/json');
  });
}

vars:post-response {
  loadTestTime: {{res.getResponseTime()}}
  loadTestDataSize: {{JSON.stringify(res.getBody()).length}}
  loadTestTimestamp: {{Date.now()}}
}
