meta {
  name: Verify Cache Miss
  type: http
  seq: 2
}

get {
  url: {{baseUrl}}/zbrodniarze
  body: none
  auth: none
}

assert {
  res.status: eq 200
  res.body: isJson
}

tests {
  test("Request after cache invalidation should be slower (cache miss)", function() {
    expect(res.getStatus()).to.equal(200);

    // After cache invalidation, this should be slower than cached requests
    // Since it needs to fetch from database
    const responseTime = res.getResponseTime();

    // Cache miss should typically take longer than 50ms (database query time)
    expect(responseTime).to.be.above(10);

    console.log(`Cache miss response time: ${responseTime}ms`);
  });

  test("Data is still valid after cache invalidation", function() {
    const zbrodniarze = res.getBody();

    expect(zbrodniarze).to.be.an('array');

    if (zbrodniarze.length > 0) {
      zbrodniarze.forEach(function(item) {
        expect(item).to.have.property('id');
        expect(item).to.have.property('username');
        expect(item).to.have.property('type');
        expect(item).to.have.property('timestamp');
      });
    }
  });

  test("Cache headers are still present", function() {
    expect(res.getHeader('cache-control')).to.equal('public, max-age=300');
    expect(res.getHeader('vary')).to.equal('Accept-Encoding');
  });

  test("Response is fresh data from database", function() {
    // This request should fetch fresh data from the database
    // We can't directly verify this, but we can check that the response
    // is structurally correct and took reasonable time for a DB query

    expect(res.getBody()).to.be.an('array');
    expect(res.getResponseTime()).to.be.below(5000); // Should still be reasonable
  });

  test("Data ordering is maintained", function() {
    const zbrodniarze = res.getBody();

    if (zbrodniarze.length > 1) {
      for (let i = 0; i < zbrodniarze.length - 1; i++) {
        const current = new Date(zbrodniarze[i].timestamp);
        const next = new Date(zbrodniarze[i + 1].timestamp);

        expect(current.getTime()).to.be.at.least(next.getTime());
      }
    }
  });

  test("Performance comparison with previous cached request", function() {
    const currentTime = res.getResponseTime();
    const previousCachedTime = bru.getVar('secondRequestTime');

    if (previousCachedTime) {
      const slowdownRatio = currentTime / parseFloat(previousCachedTime);
      console.log(`Slowdown after cache invalidation: ${slowdownRatio.toFixed(2)}x slower`);

      // After invalidation, it should be slower than the cached version
      expect(slowdownRatio).to.be.above(1.0);
    }
  });

  test("Content-Type is correct", function() {
    expect(res.getHeader('content-type')).to.equal('application/json');
  });
}

vars:post-response {
  cacheMissTime: {{res.getResponseTime()}}
  cacheMissData: {{JSON.stringify(res.getBody())}}
  postInvalidationDataLength: {{res.getBody().length}}
}
